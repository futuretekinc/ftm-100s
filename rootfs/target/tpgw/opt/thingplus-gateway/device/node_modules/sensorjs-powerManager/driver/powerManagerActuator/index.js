'use strict';
var util = require('util');

var SensorLib = require('../../index'),
    Actuator = SensorLib.Actuator,
    logger = Actuator.getLogger(),
    helper = require('../../helper');

function PowerManagerActuator(sensorInfo, options) {
  var self = this;
  Actuator.call(this, sensorInfo, options);

  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }
  if (sensorInfo.device) {
    this.meterMac = sensorInfo.device.address && sensorInfo.device.address.toUpperCase();
  }

  if (!this.meterMac) {
    logger.fatal('[PowerManagerActuator] no meterMac', sensorInfo);
    //FIXME: throw error
    return;
  }

  helper.init(function (err) {
    if (err) {
      logger.error('[PowerManagerActuator] init fail', self.meterMac, err);
    }
    helper.initClient(self.meterMac, function(err) {
      if (err) {
        logger.error('[PowerManagerActuator] initClient fail', self.meterMac, err);
      }
    });
  });
  logger.debug('PowerManagerActuator', sensorInfo);
}

PowerManagerActuator.properties = {
  supportedNetworks: ['powerManager'],
  dataTypes: ['powerSwitch'],
  discoverable: false,
  addressable: true,
  maxInstances: 5,
  idTemplate: '{model}-{address}',
  models: ['B310WA'],
  commands: ['on', 'off'],
  category: 'actuator'
};

util.inherits(PowerManagerActuator, Actuator);

PowerManagerActuator.prototype.on = function (options, cb) {
  var self = this,
  duration = options && Number(options.duration, 10);

  self.clearTimer();
  helper.setData(self.meterMac, {onoff: true}, function (err) {
    if (duration) {
      this.offTimer = setTimeout(function () {
        self.offTimer = null;
        self.off();
      }, duration);
    }
    logger.info('[PowerManagerActuator] on command with ', options);
    return cb && cb(err, self.id + 'is on');
  });
};

PowerManagerActuator.prototype.off = function (options, cb) {
  var self = this;

  self.clearTimer();
  helper.setData(self.meterMac, {onoff: false}, function (err) {
    logger.info('[PowerManagerActuator] off command with ', options);
    return cb && cb(err, self.id + ' is off');
  });
};

PowerManagerActuator.prototype.clearTimer = function () {
  if (this.blinkTimer) {
    clearInterval(this.blinkTimer);
    this.blinkTimer = null;
  }
  if (this.offTimer) {
    clearTimeout(this.offTimer);
    this.offTimer = null;
  }
};
PowerManagerActuator.prototype._clear = function () {
  var self = this;

  logger.warn('[PowerManagerActuator] _clear', this.ipAddr);
  self.clearTimer();
  //FIXME: since reference count is not considered, only power sensor can finalize
  //helper.finClient(self.meterMac); 
  return;
};

module.exports = PowerManagerActuator;
