'use strict';
var dgram = require('dgram'),
    _ = require('lodash'),
    net = require('net'),
    logger = require('log4js').getLogger('Sensor');

var DISCOVERY_PORT = 4999,
    PORT = 5000,
    RETRY_INTERVAL = 30000,
    SEP = 47, //'/'
    MAX_PACKET_SIZE = 256,
    STX = 0xfa,
    ETX = 0xfb,
    CR = 0x0d,
    DISCOVERY_MSG = new Buffer('PM Req!'),
    INITOK_MSG = new Buffer('PM Ready!'),
    REPORT_INTERVAL = 30000;

var COMMAND_NAMES = {
  0x40: 'status',
  0x41: 'initData',
  0x51: 'initTime',
  0x57: 'statusChange', //relay on/off
  0x5a: 'version',
  0x5c: 'billSet',
  0x5d: 'monthPower',
  0x5f: 'opSatus',
  0x59: 'onoffSched',
  0x65: 'nicknameSet',
  0x66: 'goal',
  0x68: 'period',
  0x6d: 'iconAck',
  0x73: 'timerSet',
  0x74: 'push', // data get
  0x75: 'startTime',
  0x76: 'waitPower',
};

var _cache = {}, _broadcastSocket;

//func
var discover, initClient;

function isBitSet(v, idx) {
  /*jshint bitwise: false */
  return (v & (1 << idx)) !== 0;
}

function parseUdpStat(packet) {
  var udpStat = {};
  var offset = 0, len, i;

  
  if (!packet || packet.length < 40) {
    if (packet.length === DISCOVERY_MSG.length &&
      packet.toString() === DISCOVERY_MSG.toString()) { //ignore request packet
      logger.debug('[parseUdpStat] ignore', DISCOVERY_MSG.toString());
    } else if (packet.length === INITOK_MSG.length &&
      packet.toString() === INITOK_MSG.toString()) { 
      logger.warn('[parseUdpStat] ', INITOK_MSG.toString());
    } else { 
      logger.error('[parseUdpStat]invalid packet.len=', packet.length, packet);
    }
    return;
  }

  // meterMac
  len = 6;
  udpStat.meterMac = packet.toString('utf8', offset, offset + len);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //ipaddr
  len = 0;
  for(i = offset; i < packet.length; i++) {
    if (packet[i] === SEP) {
      len = i - offset; // excluding null
      break;
    }
  }
  udpStat.ipAddr =  packet.toString('utf8', offset, offset + len);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //nickname
  len = 15;
  udpStat.nickName =  packet.toString('utf8', offset, offset + len);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //current power
  len = 4;
  udpStat.currentPower =  packet.readFloatLE(offset);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //power
  len = 4;
  udpStat.power =  packet.readFloatLE(offset);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //goal
  len = 4;
  udpStat.goal =  packet.readFloatLE(offset);
  offset += len;
  if (packet[offset++] !== 47) { logger.error('[parseUdpStat]parse error', offset - 1); return;}

  //status
  udpStat.statusBits = packet[offset];
  udpStat.status = {
    relay: isBitSet(udpStat.statusBits, 0),
    saving: isBitSet(udpStat.statusBits, 1),
    led: isBitSet(udpStat.statusBits, 2),
    timer: isBitSet(udpStat.statusBits, 3),
    schedule: isBitSet(udpStat.statusBits, 4),
    sound: isBitSet(udpStat.statusBits, 5),
    initialize: isBitSet(udpStat.statusBits, 6),
    start: isBitSet(udpStat.statusBits, 7),
  };

  return udpStat;
}

function makePacket(packet) {
  var buf = new Buffer(MAX_PACKET_SIZE),
  offset = 0, i = 0, chksum =0;

  buf[offset++] = STX; //stx
  buf.write(packet.meterMac, offset); //metermac
  offset += packet.meterMac.length;

  buf[offset++] = packet.command;
  switch (packet.command) {
  case 0x50: //status
    buf[offset++] = packet.overload;
    buf[offset++] = packet.saving; 
    break;
  case 0x57: //status
    buf[offset++] = packet.statusBits;
    buf[offset++] = packet.overload || 0x0;
    buf[offset++] = packet.saving || 0x0; 
    break;
  case 0x74: //push
    buf.write('Push', offset);
    offset += 4;
    break;
  case 0x68: //period
    buf.write(packet.period, offset);
    offset += 4;
    break;
  case 0x51: //time
    buf[offset++] = packet.time.h;
    buf[offset++] = packet.time.m;
    buf[offset++] = packet.time.s;
    break;
  }
  buf[offset++] = ETX; //etx
  for(i=0; i < offset; i++) {
  /*jshint bitwise: false */
    chksum = chksum ^ buf[i];
  }
  buf[offset++] = chksum; //chksum
  buf[offset++] = CR; //cr
  logger.debug('[sendPkt]', COMMAND_NAMES[packet.command] || 'unknown cmd', buf.slice(0, offset));
  return buf.slice(0, offset);
}

function parsePacket(packet) {
  var parsedPacket = {},
  offset = 0, i = 0, chksum = 0, len = 0;

  if (packet[0] !== STX || packet[packet.length-1] !== CR || 
  packet[packet.length-3] !== ETX) {
    logger.error('[parsePacket]parsePacket error stx, etx, cr error');
    return null;
  }
  for(i=0; i < packet.length - 2; i++) {
  /*jshint bitwise: false */
    chksum = chksum ^ packet[i];
  }
  if (packet[packet.length-2] !== chksum) {
    logger.error('[parsePacket]parsePacket chksum error', packet);
    return;
  }
  offset = 1; 
  len = 6;
  parsedPacket.meterMac = packet.toString('utf8', offset, offset + len);
  offset += len; //command
  parsedPacket.command = packet[offset++];

  switch (parsedPacket.command) {
  case 0x50: //status
    parsedPacket.status = packet[offset++];
    break;
  case 0x40: // status reply
    parsedPacket.currentPower = packet.readFloatLE(24);
    parsedPacket.power = packet.readFloatLE(28);
    break;
  case 0x68: // period
    len = 4;
    parsedPacket.period = packet.toString('utf8', offset, offset + len);
    break;
  case 0x41: // init data
    parsedPacket.statusBits = packet[offset];
    parsedPacket.status = {
      relay: isBitSet(parsedPacket.statusBits, 0),
      saving: isBitSet(parsedPacket.statusBits, 1),
      led: isBitSet(parsedPacket.statusBits, 2),
      timer: isBitSet(parsedPacket.statusBits, 3),
      schedule: isBitSet(parsedPacket.statusBits, 4),
      sound: isBitSet(parsedPacket.statusBits, 5),
      initialize: isBitSet(parsedPacket.statusBits, 6),
      start: isBitSet(parsedPacket.statusBits, 7),
    };
    break;
  default:
    break;
  }
  return parsedPacket;
}

function parsePackets(packet) {
  var i = 0, offset = 0, parsedPkt, parsedPkts = [];
  for(i = 0; i < packet.length - 2; i++) {
    if (packet[i] === ETX && packet[i+2] === CR) {
      parsedPkt = parsePacket(packet.slice(offset, i + 2 + 1));
      offset = i + 2 + 1;
      if (parsedPkt) {
        parsedPkts.push(parsedPkt);
      }
    }
  }
  return parsedPkts;
}

var _initialized = false;
var _underInit = false;
function init(cb) {
  var initTimer, maxRetries = 150;
  if (_underInit) {
    //polling until initialized
    initTimer = setInterval(function () {
      maxRetries--;
      if (_initialized || maxRetries < 0) {
        if (initTimer) {
          clearInterval(initTimer);
          initTimer = null;
        }
        if (maxRetries < 0) {
          logger.error('[helper.init] failure: timeout');
          return cb && cb(new Error('timeout'));
        } else {
          return cb && cb();
        }
      }
    }, 2000);
    return;
  }
  if (_initialized) {
    return cb && cb();
  }
  _underInit = true;
  _broadcastSocket = dgram.createSocket('udp4');
  _broadcastSocket.bind(DISCOVERY_PORT);
  _broadcastSocket.on('listening', function() {
    _broadcastSocket.setBroadcast(true);
    discover({force: true}, function (err, deviceInfos) {
      _initialized = true;
      _underInit = false;
      if (err) {
        logger.error('INITIAL discover err', err);
      } else {
        logger.info('INITIALY DISCOVERD', deviceInfos);
      }
      return cb && cb();
    });
  });
  _broadcastSocket.on('message', function(msg, rinfo) {
    var parsedStat;
    if (!msg || !rinfo) {
      return;
    }
    logger.debug('udp message', rinfo);
    parsedStat = parseUdpStat(msg);
    if (!parsedStat) {
      return;
    }
    if (parsedStat.ipAddr !== rinfo.address) {
      logger.error('[helper.init]ipAddr mismatch', parsedStat);
      return;
    }

    if (!_cache[parsedStat.meterMac]) {
      _cache[parsedStat.meterMac] = {};
    }
    _cache[parsedStat.meterMac].stat = parsedStat;
  });
}

//find a device with given meterMac, or find all
function discoverDevices(cb) {
  var retryTimer, retryCount = 3;
  var ipAddr = '255.255.255.255';

  logger.debug('[send udp]', ipAddr);
  _broadcastSocket.send(DISCOVERY_MSG, 0, DISCOVERY_MSG.length, DISCOVERY_PORT, ipAddr);
  retryCount--;
  retryTimer = setInterval(function () {
    retryCount--;
    if (!_.isEmpty(_cache) || retryCount < 0) {
      clearInterval(retryTimer);
      retryTimer = null;
      return cb && cb();
    }
    logger.debug('[send udp]', ipAddr);
    _broadcastSocket.send(DISCOVERY_MSG, 0, DISCOVERY_MSG.length, DISCOVERY_PORT, ipAddr);
  }, RETRY_INTERVAL);

  _broadcastSocket.once('error', function(err) {
    logger.debug('[discoverDevices] _broadcastSocket error', ipAddr, err);
    if ( retryTimer) {
      clearInterval(retryTimer);
      retryTimer = null;
      return cb && cb(err);
    }
  });
}

//FIXME: since reference count is not considered, only power sensor can finalize
function finClient(meterMac) {
  var me = _cache[meterMac];
  
  if (!me) { return; }

  if (me.reconnectTimer) { //clear reconnect timer
    clearTimeout(me.reconnectTimer);
    me.reconnectTimer = null; 
  }
  if (me.dataTimer) { //clear dataTimer timer
    clearTimeout(me.dataTimer);
    me.dataTimer = null; 
  }

  me.client.end();
  me.client.destroy();

  me.client = null;
}

function getData(meterMac, cb) {
  var me = _cache[meterMac];
  if (!me) { 
    //FIXME: assuming only one device 
    if (_.isEmpty(_cache)) {
      logger.warn('[getData] try to discover since no device ');
      discover({force: true}, function () {
        if (_cache[meterMac]) { //found 
          initClient(meterMac);
        }
      });
    }
    return cb && cb(new Error('not found'));
  }
  if (!me.client && !me.isConnected) {
    initClient(meterMac);
  }
  if (!me.last || !me.last.data || (Date.now() - me.last.time) > (RETRY_INTERVAL* 1.5)) {
    return cb && cb(new Error('data not ready'));
  }

  return cb && cb(null, { 
    currentPower: me.last.data.currentPower,
    power: me.last.data.power,
  });
}

function getDeviceInfos() {
  var deviceInfos = [];
  _.each(_cache, function (device, meterMac) {
    deviceInfos.push({
      id: meterMac,
      ipAddr: device.stat.ipAddr,
      sensorInfos: [{
        id: 'B310WS-' + meterMac,
        model: 'B310WS',
        device: {
          sensorNetwork: 'powerManager',
          address: meterMac
        },
      }, {
        id: 'B310WA-' + meterMac,
        model: 'B310WA',
        device: {
          sensorNetwork: 'powerManager',
          address: meterMac
        },
      }]
    });
  });
  return deviceInfos;
}

var _underDiscover = false;
//for now, discover device once
discover = function discover(options, cb) {
  if (_.isFunction(options)) {
    cb = options;
    options = {};
  }
  var force = options && options.force;

  if (_underDiscover) {
    logger.error('[discover] under discover');
    return cb && cb(new Error ('[discover] under discover'));
  }
  if (!_.isEmpty(_cache) || !force) { // FIXME: assuming only one device
    return cb && cb(null, getDeviceInfos());
  }

  _underDiscover = true;
  discoverDevices(function () {
    _underDiscover = false;
    return cb && cb(null, getDeviceInfos());
  });
};

//FIXME: this works only if getData is called repeatedly
function setData(meterMac, cmd, cb) {
  var me = _cache[meterMac],
  myStat = me && me.stat;

  if (!me || !myStat || !me.client) {
    return cb && cb(new Error('no client or not found'));
  }

  if (!me.isConnected || !me.last || !me.last.data || 
    (Date.now() - me.last.time) > (RETRY_INTERVAL * 1.5)) {
    return cb && cb(new Error('Not connected'));
  }

  /*jshint bitwise: false */
  if (cmd && cmd.onoff) {
    myStat.statusBits = myStat.statusBits | 0x01;
    myStat.status.relay = true;
  } else {
    myStat.statusBits = myStat.statusBits &  ~0x01;
    myStat.status.relay = false;
  }
  me.client.write(makePacket({
    meterMac: meterMac,
    command: 0x57, //status
    statusBits: myStat.statusBits,
  })); 
  return cb && cb();
}

initClient = function initClient(meterMac, cb) {
  var me = _cache[meterMac],
  myStat = me && me.stat;

  if (!me || !myStat) {
    logger.error('[initClient]not found', meterMac);
    return cb && cb(new Error('not found'));
  }
  if (me.isConnected) {
    logger.info('[initClient]already tcp connected', meterMac);
    return cb && cb();
  }
  me.isConnected = true;

  function _connectCB(err) {
    if (me.dataTimer) {
      clearInterval(me.dataTimer);
      me.dataTimer = null;
    }
    if (err) {
      logger.error('[initClient]_connectCB err=', err);
      return;
    }
    function _getData() {
      if (!me.client) {
        logger.error('[initClient]dataTimer no client');
        return;
      }

      //reconnect
      if (me.last && (Date.now() - me.last.time) > RETRY_INTERVAL) {
        logger.error('[initClient]reconnect');
        if (me.dataTimer) { //clear this timer
          clearInterval(me.dataTimer);
          me.dataTimer = null;
        }
        me.client.destroy(); //close

        me.last = null; //clear last one
        return;
      }
      me.client.write(makePacket({ // send push
        /*jshint bitwise: false */
        meterMac: meterMac,
        command: 0x74, //push
      })); 
    }
    if (!err) {
      me.dataTimer = setInterval(_getData, REPORT_INTERVAL);
      var now = new Date();
      setTimeout(function () {
        me.client.write(makePacket({
          meterMac: meterMac,
          command: 0x51, //time
          time: {
            h: now.getHours(),
            m: now.getMinutes(),
            s: now.getSeconds(),
          },
        }));
      }, REPORT_INTERVAL / 2);
    } else {
      me.isConnected = false;
      me.client = null;
    }
  }

  me.client = new net.Socket();
  me.client.connect(PORT, myStat.ipAddr);
  me.client.on('connect', _connectCB);

  me.client.on('error', function () {
    //reconnect
    return me.client && me.client.destroy();
  });

  me.client.on('close', function () {

    logger.info('close', meterMac);
    if (!me.client) {
      //finClient is called
      return;
    }
    if (me.dataTimer) {
      clearInterval(me.dataTimer);
      me.dataTimer = null;
    }
    me.reconnectTimer = setTimeout(function () {  
      me.client.connect(PORT, myStat.ipAddr);
      me.reconnectTimer = null;
    }, RETRY_INTERVAL);
  });

  me.client.on('data', function (data) {
    _.each(parsePackets(data), function (parsedPkt) {
      if (!parsedPkt) {
        logger.error('[initClient]command parse error', data.toString('hex'));
        return;
      }

      logger.debug('[recvPkt]', new Date(), 'cmd='  + COMMAND_NAMES[parsedPkt.command] || Number(parsedPkt.command).toString(16), parsedPkt);
      switch (parsedPkt.command) {
      case 0x40: // status
        me.last = {
          data: parsedPkt,
          time: Date.now(),
        };
        break;
      default:
        break;
      }
    });
  });

  return cb && cb();
};

//udp broadcast socket init and initial discover
module.exports.init = init;
//params: options {force: true/false}, cb
module.exports.discover = discover;
//params: meterMac, cb
module.exports.getData = getData;
//params: meterMac, cmd: {onoff: true}, cb
module.exports.setData = setData;
//params: meterMac
module.exports.initClient = initClient;
//params: meterMac
module.exports.finClient = finClient;

//run directly from node, example:
if (require.main === module) {
  init(function () {
    initClient('1B0124', function () {
      logger.error('initClient done');
    });
  });

  var toggleValue = true;
  setInterval(function () {
    if (toggleValue) {
      toggleValue = false;
    } else {
      toggleValue = true;
    }
    setData('1B0124', {onoff: toggleValue}, function (err) {
      logger.info(new Date(), 'setData err', err);
    });
  }, 60000);
}
