'use strict';
var events      = require('events'),
util      = require('util'),
mysql      = require('mysql'),
_      = require('lodash'),
async      = require('async'),
logger = require('log4js').getLogger('Sensor');


var DEFAULT_DB_CONFIG = {
  host     : 'localhost',
  database : 'MeshliumDB',
  user     : 'root',
  password : 'libelium'
},
RECONNECT_INTERVAL = 60 * 1000,
POLLING_INTERVAL = 3 * 1000,
VALID_TIME_LIMIT = POLLING_INTERVAL * 3,
DB_QUERY_LIMIT = 10;

var connection,
_isConnected = false, underConnect = false, isInitialized = false;

var lastId;

function Monitor() {
  events.EventEmitter.call(this);
}
util.inherits(Monitor, events.EventEmitter);
var monitor = exports.monitor = new Monitor();

//func decl
var reconnect;

function getHtmlColorCode(r, g, b) {
  var color = '#';
  _.each([r,g,b], function (v) {
    var num = Number(v);
    if (_.isNaN(num) || num > 255 || num < 0) {
      color += '00';
    } else {
      color += (num < 10 ? '0' : '') +  num.toString(16).toUpperCase();
    }
  });
  return color;
}

/**
@param {String} row to parse
@return {Object} sensorData
time: {Number} in ms
sync: {Boolean} syned?
values: {Object} value with type key
*/
function parseSensorData(row) {
  var rtnArr = [],
  lines = row.raw && row.raw.split('\n');

  _.each(lines, function (line) {

    line = line && line.trim();
    if (_.isEmpty(line)) {
      return;
    }

    /*jshint bitwise: false*/
    var sensorData = {};

    sensorData.time = Date.parse(row.timestamp) || _.now();
    sensorData.sync = !!(row.sync | 0x2);
    sensorData.values = {};
    if (!_.isEmpty(row['id_wasp'])) {
      sensorData.deviceAddress = row['id_wasp'];
    }
    // separators: sensors(#), : type and value(:), values(';')
    _.each(line.split('#'), function (v) {
      var spts = v.split(':'),
      type = spts[0],
      val = (spts[1] && spts[1].split(';')) || [], 
      i;
      switch(type) {
        case 'I':
          sensorData.deviceAddress = val[0];
          break;
        case 'N':
          sensorData.values.serial = val[0];
          break;
        case 'COUNT':
          sensorData.values.count = val;
          break;
        case 'WEIGHT': //WET_1K, WET_5K
          sensorData.values.weight = val;
          break;
        case 'EVENTS': //LENGTH, SHAPE
          sensorData.values.onoff = val;
          break;
        case 'CT':
        case 'TMP':
        case 'TMPLIQ':
        case 'TMPGAS':
          sensorData.values.temperature = val;
          break;
        case 'CH':
          sensorData.values.humidity = val;
          break;
        case 'CL':
        case 'LDR':
          sensorData.values.light = val;
          break;
        case 'CN':
        case 'AUD':
        case 'NOISE':
          sensorData.values.noise = val;
          break;
        case 'CD':
          sensorData.values.dust = val;
          break;
        case 'CO':
          sensorData.values.co = val;
          break;
        case 'CO2':
          sensorData.values.co2 = val;
          break;
        case 'VOC':
          sensorData.values.voc = val;
          break;
        case 'COLOR':
          for(i=0; i < _.size(val); i+=3) {
            if (!sensorData.values.color) { sensorData.values.color = []; }
            sensorData.values.color.push(getHtmlColorCode(val[i], val[i+1], val[i+2]));
          }
          break;
        case 'VIB':
          sensorData.values.vibration = val;
          break;
        case 'SPEED':
          sensorData.values.speed = val;
          break;
      }
    });
    rtnArr.push(sensorData);
  });
  return rtnArr;
}

function syncSensorData(row, cb) {
  var id, syncNew;
  if (_.isObject(row)) {
    id = row.id;
    /*jshint bitwise: false*/
    syncNew = (row.sync || 0x0) | 0x2;
  } 

  if (row.sync & 0x2) { //already sync
    return cb && cb();
  }
  if (!id) {
    return cb && cb(new Error('[syncSensorData]invalid id'));
  }
  if (!_isConnected) {
    reconnect();
    return cb && cb(new Error('not connected'));
  }
  var queryStr = 'UPDATE sensorParser SET sync=' + syncNew + ' where id=' + id + ';';
  connection.query(queryStr,
    function (err, result) {
      if (err) {
        logger.error('error query=', queryStr, ' err=', err);
        _isConnected = false;
        reconnect();
      } else if (!result.changedRows) {
        logger.error('none changed', result.changedRows);
        err = new Error('no data updated');
      } else {
        logger.debug('sync ok query=', queryStr);
      }
      return cb && cb(err);
    });
}

function getLastId(cb) {
  if (!_isConnected) {
    reconnect();
    return cb && cb(new Error('not connected'));
  }
  var queryStr = 'SELECT * FROM sensorParser ORDER BY id DESC LIMIT 1;';
  connection.query(queryStr, function(err, rows) {
    if (_.size(rows) === 1) {
      lastId = rows[0].id;
      var sensorDataArr = parseSensorData(rows[0]);
      var sensorData = sensorDataArr[0];
      if (sensorData.sync) {
        logger.info('[getLastId] already synced', sensorData);
      } else {
        if (sensorData.time && (_.now() - sensorData.time < VALID_TIME_LIMIT)) {
          if (sensorData.deviceAddress) {
            monitor.emit('data', sensorData);
            logger.debug('[getLastId] emit data', sensorData);
          } else {
            logger.error('[getLastId]missing deviceAddress', sensorData);
          }
        } else {
          logger.error('[getLastId]too old data', sensorData);
        }
        syncSensorData(rows[0]);
      }
    } if (err) {
      _isConnected = false;
      reconnect();
    } else {
      err = new Error('no entry in sensorParser');
    }
    return cb && cb(err);
  });
}

function initConnection(cb) {
  if (underConnect) {
    return cb && cb(new Error('underConnect'));
  }
  if (_isConnected) {
    return cb && cb(); //already connected
  }

  underConnect = true;
  connection.connect(function (err) {
    underConnect = false;
    if (err) {
      logger.error('error connecting: ' + err.stack);
      _isConnected = false;
      return cb && cb(err);
    }

    logger.info('connected success as id ' + connection.threadId);
    _isConnected = true;
    if (!lastId) {
      getLastId(function (err) {
        return cb && cb(err);
      });  
    } else {
      return cb && cb(err);
    }
  });
}

function getSensorData(cb) {
  var rowsLen = 0;
  if (!_isConnected) {
    reconnect();
    return cb && cb(new Error('not connected'));
  }
  if (!lastId) { //get last id if not exist, data emit on getting last id.
    return getLastId(cb);
  }
  async.doWhilst(function (done) {
    var queryStr = 'SELECT * FROM sensorParser where id > ' + lastId +
      ' AND ' + 'sync&2=0 ' + 'ORDER BY id LIMIT ' + DB_QUERY_LIMIT + ';';
    connection.query(queryStr, function(err, rows/*, fields*/) {
      if (err) {
        logger.error('query=', queryStr, 'err=', err);
        _isConnected = false;
        reconnect();
        return done(err);
      }
      logger.debug('query=', queryStr, 'row_len=', rows.length);
      async.eachSeries(rows || [], function (row, done2) {

        var sensorDataArr = parseSensorData(row);
        _.each(sensorDataArr, function(sensorData) {
          if (sensorData.deviceAddress) {
            monitor.emit('data', sensorData);
            logger.debug('[getSensorData] emit data', sensorData);
          } else {
            logger.error('[getSensorData]missing deviceAddress', sensorData);
          }
        });

        syncSensorData(row, function (err) { //sync
          if (err) { logger.error('[syncSensorData] done2 err', err); }
          return done2(); // ignore error
        });
      }, function (err) {
        var lastRow = _.last(rows);
        if (lastRow && lastRow.id) {
          lastId = lastRow.id;
        }
        return done && done(err);
      });
    });
  },
  function () { // do while the size of rows match with limit(10)
    return (rowsLen === DB_QUERY_LIMIT);
  },
  function (err) {
    if (err) {
      logger.error('error to access mysql', err);
    }
    return cb && cb(err);
  });
}
function init(options, cb) {
  if (isInitialized) {
    return cb && cb();
  }
  isInitialized = true;

  connection = mysql.createConnection(_.defaults(options || {}, DEFAULT_DB_CONFIG));
  connection.on('error', function() {
    _isConnected = false;
    logger.error('[mysqlHelper] conn error');
  });

  return initConnection(function () {
    var polling = function () {
      getSensorData(function (err) {
        if (err) {
          logger.info('getSensorData err', err);
        }
        setTimeout(polling, POLLING_INTERVAL);
      });
    };
    polling();
    return cb && cb(); // ignore error
  });
}


function finConnection() {
  connection.end();
  _isConnected = false;
  underConnect = false;
}

reconnect = _.throttle(function() {
  if (_isConnected) {
    return;
  } else {
    finConnection();
    initConnection();
  }
}, RECONNECT_INTERVAL, {trailing: false});

function isConnected() {
  return _isConnected;
}

exports.init = init;
exports.monitor = monitor;
exports.isConnected = isConnected;
