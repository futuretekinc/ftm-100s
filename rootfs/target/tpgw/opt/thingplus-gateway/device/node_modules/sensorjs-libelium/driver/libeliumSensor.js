'use strict';
var util = require('util'),
    _ = require('lodash');

var SensorLib = require('../'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger(),
    mysqlHelper = require('../mysqlHelper');

function LibeliumSensor(sensorInfo, options) {
  var self = this;
  Sensor.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }

  this._getTimeout = (options && Number(options.getTimeout)) || LibeliumSensor.properties.recommendedInterval * 2;
  this.dataType = _.first(LibeliumSensor.properties.dataTypes[this.model]);

  logger.debug('LibeliumSensor', sensorInfo);

  if (!_.isUndefined(sensorInfo.device.address)) {
    this.deviceAddress = sensorInfo.device.address;

    logger.info('LibeliumSensor sensor(addr: %s) is created at driver', this.deviceAddress, sensorInfo);
  } else {
    logger.error('LibeliumSensor sensor address or network is not provided', sensorInfo);
  }

  this.channel = this.id && Number(_.last(this.id.split('-')));
  if (_.isUndefined(this.channel) || _.isNaN(this.channel) ) {
    logger.error('LibeliumSensor channel is undefined or NaN', sensorInfo);
    this.channel = 0;
  }

  mysqlHelper.init();
  mysqlHelper.monitor.on('data', function (sensorData) {
    var rtn;

    if (sensorData.deviceAddress &&
      sensorData.deviceAddress !== self.deviceAddress) { // NOT for this device
      //logger.debug('LibeliumSensor not for this device', sensorData);
      return;
    }
    // error could not have deviceAddress
    if (sensorData instanceof Error &&
        (!sensorData.deviceAddress || sensorData.deviceAddress === self.deviceAddress)) {
      rtn = {
        id: self.id,
        status: 'error',
        message: sensorData.message,
      };
      if (self.enableChange) { self.emit('change', rtn); }
      self.emit('data', rtn);
      if(self._getTimer) {
        clearTimeout(self._getTimer);
        self._getTimer = null;
      }
      return;
    }
    
    if (!sensorData.deviceAddress) {
      logger.error('LibeliumSensor NO deviceAddress', sensorData);
      return;
    }
    
    if (!_.isUndefined(sensorData.values[self.dataType])) {
      rtn = {
        id: self.id,
        status: 'ok',
        result: {},
      };
      rtn.result[self.dataType] = sensorData.values[self.dataType][self.channel];
      if (sensorData.time) {
        rtn.time =  {};
        rtn.time[self.dataType] = sensorData.time;
      }
      logger.debug('[libeliumSensor] data', rtn);
      if (self.enableChange) { self.emit('change', rtn); }
      self.emit('data', rtn);

      if(self._getTimer) {
        clearTimeout(self._getTimer);
        self._getTimer = null;
      }
      return;
    }
  });
}


LibeliumSensor.properties = {
  supportedNetworks: ['libelium'],
  dataTypes: { // use hash for diff types depending on model
    libeliumTemp: ['temperature'],
    libeliumHumi: ['humidity'],
    libeliumLight: ['light'],
    libeliumNoise: ['noise'],
    libeliumCo2: ['co2'],
    libeliumCo: ['co'],
    libeliumVoc: ['voc'],
    libeliumCount: ['count'],
    libeliumWeight: ['weight'],
    libeliumColor: ['color'],
    libeliumVibration: ['vibration'],
    libeliumSpeed: ['speed'],
    libeliumOnoff: ['onoff']
  },
  onChange: {
    libeliumTemp: false,
    libeliumHumi: false,
    libeliumLight: false,
    libeliumNoise: false,
    libeliumCo2: false,
    libeliumCo: false,
    libeliumVoc: false,
    libeliumCount: false,
    libeliumWeight: false,
    libeliumColor: false,
    libeliumVibration: false,
    libeliumSpeed: false,
    libeliumOnoff: true
  },
  discoverable: false,
  recommendedInterval: {
    libeliumTemp: 30000,
    libeliumHumi: 30000,
    libeliumLight: 30000,
    libeliumNoise: 30000,
    libeliumCo2: 30000,
    libeliumCo: 30000,
    libeliumVoc: 30000,
    libeliumCount: 30000,
    libeliumWeight: 30000,
    libeliumColor: 30000,
    libeliumVibration: 30000,
    libeliumSpeed: 30000,
    libeliumOnoff: 30000
  },
  idTemplate: '{gatewayId}-{deviceAddress}-{type}-{sequence}',
  models: ['libeliumTemp', 'libeliumHumi', 'libeliumLight', 
    'libeliumNoise', 'libeliumCo2', 'libeliumCo', 'libeliumVoc',
    'libeliumCount', 'libeliumWeight', 'libeliumColor', 'libeliumVibration', 
    'libeliumSpeed', 'libeliumOnoff'],
  category: 'sensor'
};

util.inherits(LibeliumSensor, Sensor);

LibeliumSensor.prototype._get = function () {
  var self = this,
      rtn = { id: self.id};

  if (!mysqlHelper.isConnected()) {
    logger.error('libeliumSensor:not connected', self.id, self.model);

    rtn.status = 'error';
    rtn.message = 'not connected';
    self.emit('data', rtn);
    return;
  }

  if (!self.deviceAddress) {
    logger.error('LibeliumSensor NO self.deviceAddress', self.id);
    rtn.status = 'error';
    rtn.message = 'NO deviceAddress';
    self.emit('data', rtn);
    return;
  }

  if (self._getTimer) {
    return;
  }

  //only first time, set timeout for recommendedInterval*2
  self._getTimer = setTimeout(function () {
    self._getTimer = null;
    rtn = {
      id: self.id,
      status: 'error',
      message: 'timeout',
    };
    self.emit('data', rtn);
    return;
  }, self._getTimeout);
};

LibeliumSensor.prototype._enableChange = function () {
  var self = this;

  if (LibeliumSensor.properties.onChange[self.model]) {
    logger.debug('LibeliumSensor:_enableChange');
    self.enableChange = true;
  } else {
    throw new Error('enable change for non-event');
  }
};

LibeliumSensor.prototype._clear = function () {
  var self = this;
  if(self._getTimer) {
    clearTimeout(self._getTimer);
    self._getTimer = null;
  }
};

module.exports = LibeliumSensor;
