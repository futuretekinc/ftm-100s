'use strict';

var util = require('util');

var SensorLib = require('../index'),
    rpcHelper = require('../rpcHelper'),
    _ = require('lodash'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger();

function JsonrpcSensor(sensorInfo, options) {
  Sensor.call(this, sensorInfo, options);

  var self = this;
  if (!this.device.address) {
    logger.fatal('[JsonrpcSensor] no device address', sensorInfo);
    //FIXME: throw error
    return;
  }
  
  this.shortId = this.id.substr(this.id.indexOf('-')+1);

  rpcHelper.init();

  this.options =  _.defaults(options || {}, sensorInfo.options);
  if (this.options && 
  (this.options.notification === true||this.options.notification === 'true')) {
    this._enableLog();
    this.isNotification = true;
  }

  rpcHelper.on('connect', function () {
    if (self.logListener) { self._enableLog(); }
    if (self.changeListener) { self._enableChange(); }
  });
  
  logger.debug('[JsonrpcSensor]', sensorInfo);
}

JsonrpcSensor.properties = {
  supportedNetworks: ['jsonrpc'],
  dataTypes: {
    jsonrpcTemp: ['temperature'],
    jsonrpcHumi: ['humidity'],
    jsonrpcDi: ['onoff'],
    jsonrpcMotion: ['onoff'],
    jsonrpcGas: ['co2'],
    jsonrpcPower: ['power'],
    jsonrpcDust: ['dust'],
    jsonrpcPressure: ['pressure']
  },
  onChange: {
    jsonrpcTemp: false,
    jsonrpcHumi: false,
    jsonrpcDi: true,
    jsonrpcMotion: true,
    jsonrpcGas: false,
    jsonrpcPower: false,
    jsonrpcDust: false,
    jsonrpcPressure: false,
  },
  discoverable: true,
  addressable: false, //given manually as param
  recommendedInterval: 30000,
  maxInstances: 1,
  idTemplate: '{gatewayId}-{deviceAddress}-{type}-{sequence}',
  models: ['jsonrpcTemp', 'jsonrpcHumi', 'jsonrpcDi', 'jsonrpcMotion', 'jsonrpcGas', 'jsonrpcPower', 'jsonrpcDust', 'jsonrpcPressure'],
  category: 'sensor'
};

util.inherits(JsonrpcSensor, Sensor);

JsonrpcSensor.prototype._get = function () {
  var self = this; 

  if (self.isNotification) { return; } //skip on log enabled
  
  rpcHelper.call('sensor.get', self.shortId, function (err, result) {
    var rtn = {status: 'error', id : self.id};

    if (err || !result) {
      // FIXME: not to be here
      rtn.message = err ? err.message : 'no result';
      self.emit('data', rtn);
      logger.error('[JsonrpcSensor] no connection', err, result);
      return;
    }
    rtn.status = 'ok';
    rtn.result = {};
    rtn.result[JsonrpcSensor.properties.dataTypes[self.model][0]] = result.value;
    self.emit('data', rtn);
    return;
  });
};

JsonrpcSensor.prototype._enableLog = function () {
  var self = this;

  if (!JsonrpcSensor.properties.onChange[self.model]) {
    logger.debug('JsonrpcSensor:_enableLog');
    rpcHelper.call('sensor.setNotification', self.shortId, function (err) {
      if (err) {
        throw new Error('enable log failure');
      }
    });
    if (!self.logListener) {
      self.logListener = function (id, val) {
        var rtn = {status: 'error', id : self.id},
        type = JsonrpcSensor.properties.dataTypes[self.model][0];
        if (self.shortId === id) {
          if (!_.isUndefined(val) && !_.isUndefined(val.value)) {
            rtn.status = 'ok';
            rtn.result = {};
            rtn.result[type] = val.value;
            if (val.time) {
              rtn.time = {};
              rtn.time[type] = val.time;
            }
          } else {
            rtn.message = 'invalid value';
          }
          self.emit('data', rtn);
          return;
        }
      };
      rpcHelper.on('notification', self.logListener);
    }
  } else {
    throw new Error('enable change for event');
  }
};
JsonrpcSensor.prototype._enableChange = function () {
  var self = this;

  if (JsonrpcSensor.properties.onChange[self.model]) {
    logger.debug('JsonrpcSensor:_enableChange');
    rpcHelper.call('sensor.setNotification', self.shortId, function (err) {
      if (err) {
        throw new Error('enable change failure');
      }
    });
    if (!self.changeListener) {
      self.changeListener = function (id, val) {
        var rtn = {status: 'error', id : self.id};
        if (self.shortId === id) {
          if (!_.isUndefined(val) && !_.isUndefined(val.value)) {
            rtn.status = 'ok';
            rtn.result = {};
            rtn.result[JsonrpcSensor.properties.dataTypes[self.model][0]] = val.value;
          } else {
            rtn.message = 'invalid value';
          }
          self.emit('change', rtn);
          return;
        }
      };
      rpcHelper.on('notification', self.changeListener);
    }
  } else {
    throw new Error('enable change for non-event');
  }
};
JsonrpcSensor.prototype._clear = function () {
  var self = this;
  logger.warn('[JsonrpcSensor] _clear', this.ipAddr);
  if (self.changeListener) {
    rpcHelper.removeListener('notification', self.changeListener);
    delete self.changeListener;
  }
  if (self.logListener) {
    rpcHelper.removeListener('notification', self.logListener);
    delete self.logListener;
  }
  return;
};

module.exports = JsonrpcSensor;
