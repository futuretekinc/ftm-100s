'use strict';
var util = require('util'),
    _ = require('lodash'),
    snmp = require ('net-snmp');

var SensorLib = require('../../index'),
    Actuator = SensorLib.Actuator,
    logger = Actuator.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

var DEFAULT_BLINK_INTERVAL = 5000, // 5 secs
    THROTTLE_INTERVAL = 60*1000;

function chkSession(self, cb) {
  var network = self.info && self.info.device && 
                self.info.device.sensorNetwork &&
                SensorLib.getNetwork(self.info.device.sensorNetwork),
      prevIp = self.ip;

  if (!network || !self.info.device.address) {
    logger.error('futureSensor:chkSession invalid device info', self.info);
    return cb && cb(new Error('invalid device info'));
  }
  network.getDevice(self.info.device.address, function (err, device) {
    var si;

    self.ip = device && device.extraInfo && device.extraInfo.ipAddr;

    if (!self.ip) {
      logger.error('futureSensor:chkSession missing device', self.info);
      return cb && cb(new Error('missing device'));
    }

    si = _.find(device.extraInfo && device.extraInfo.sensorInfos, {id: self.id});
    if (si && si.oid) {
      self.oidIdx = Number(si.oid.substring(si.oid.lastIndexOf('.')+1));
    }
    if (!si || ((self.oidIdx !==0) && !self.oidIdx)) {
      logger.error('futureSensor: cannot find sensorinfo', self.id, self.oid);
    }

    if (self.ip === prevIp && self.session) {//no ip change keep session
      return cb && cb();
    } else { 
      logger.debug('futureSensor:chkSession ip change or no session:', self.id, prevIp, self.ip);
      if (self.session) {
        self.session.close();
        delete self.session;
      }
      self.session = snmp.createSession(self.ip, 'public', cfg.SNMP_OPTIONS);
      logger.warn('futureSensor:chkSession new session:', self.id, self.ip);
      return cb && cb();
    }
  });
}

function FutureActuator(sensorInfo, options) {
  Actuator.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }
  var self = this;
  //future = sensorDriver.getNetwork('future');
  logger.debug('FutureActuator', sensorInfo);
  this.oidIdx = Number(this.id.slice(-2)); // FIXME: last 2 disits from id
  var sensor = _.find(cfg.SENSOR_OIDS, {model: this.model});
  this.baseOid = sensor &&  sensor.baseOid;
  this.valueOid = sensor && 
        [sensor.baseOid, sensor.VALUE_OID, this.oidIdx].join('.');
  this.dataType = _.first(FutureActuator.properties.dataTypes[this.model]);

  this.throttledChkSession = _.throttle(_.partial(chkSession, this), 
      THROTTLE_INTERVAL, {trailing: false});
  this.throttledChkSession();

  //polling until first session being established.
  function pollingFirstSession() {
    setTimeout(function () {
      if (!self.session) {
        self.checkSession();
        pollingFirstSession();
      }
    }, THROTTLE_INTERVAL);
  }
  pollingFirstSession();
}

FutureActuator.properties = {
  supportedNetworks: ['future'],
  dataTypes: {
    futureDo: ['powerSwitch'],
    futureTempCtrl: ['temperatureController'],
  },
  discoverable: true,
  addressable: false,
  maxInstances: 5,
  models: ['futureDo', 'futureTempCtrl'],
  commands: {
    futureDo: ['on', 'off'],
    futureTempCtrl: ['get', 'set'],
  },
  category: 'actuator'
};

util.inherits(FutureActuator, Actuator);

/* options.duration: infinite if NaN, null, undefined, zero or minus */
FutureActuator.prototype.on = function (options, cb) {
  var self = this,
  duration = options && Number(options.duration, 10);


  this._clearTimer();
  if (this.dataType !== 'powerSwitch') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  if (!duration || duration <= 0) {
    duration = 0; 
  }

  this.__set(1, function (err) {
    if (duration) {
      self.offTimer = setTimeout(function () {
        self.offTimer = null;
        self.off();
      }, duration);
    }
    return _.isFunction(cb) && cb(err, err ? null : self.id + ' is on');
  });
};

FutureActuator.prototype.off = function (options, cb) {
  var self = this;

  this._clearTimer();
  if (this.dataType !== 'powerSwitch') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  this.__set(0, function (err) {
    return _.isFunction(cb) && cb(err, err ? null : self.id + ' is off');
  });
};

/* Blink 
 * interval: blink interval(default: 5 sec)
 * options.duration: infinite if NaN, null, undefined, zero or minus
 */
FutureActuator.prototype.blink = function (options, cb) {
  var self = this,
  interval = options && Number(options.interval, 10),
  duration = options && Number(options.duration, 10),
  value = 1;

  this._clearTimer();
  if (this.dataType !== 'powerSwitch') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  if (!interval || interval <= 0) {
    interval = DEFAULT_BLINK_INTERVAL; 
  }

  if (!duration || duration <= 0) {
    duration = 0; 
  }

  self.blinkTimer = setInterval(function () {
    self.__set(value, function (err) {
      value = value === 1 ? 0 : 1; // toggle value
      return _.isFunction(cb) && 
          cb(err, self.id + ' is ' + (value === 1 ? 'on' : 'off'));
    });
  }, interval || DEFAULT_BLINK_INTERVAL);

  if (duration) {
    self.offTimer = setTimeout(function () {
      clearInterval(self.blinkTimer);
      self.blinkTimer = null;
      self.offTimer = null;
      self.off();
    }, duration);
  }

  return _.isFunction(cb) && cb(null, this.id + ' is blinking');
};


FutureActuator.prototype.set = function (options, cb) {
  this._clearTimer();
  if (this.dataType !== 'powerSwitch') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  this.__set(JSON.stringify(options), function (err, result) {
    return _.isFunction(cb) && cb(err, result);
  });
};

FutureActuator.prototype.get = function (options, cb) {
  this._clearTimer();
  if (this.dataType !== 'powerSwitch') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  this.__get(function (err, result) {
    return _.isFunction(cb) && cb(err, result);
  });
};

FutureActuator.prototype.__set = function (value, cb) {
  var self = this,
    setVarbind = {
      oid: self.valueOid,
      type: snmp.ObjectType.OctetString,
      value: value.toString(),
    };

  if (!self.session) {
    self.throttledChkSession();
    logger.error('[futureActuator:_set]snmp session is not ready', self.id, self.model, self.ip);
    return cb && cb(new Error('snmp session is not ready'));
  }

  snmpHelper.setSNMP(self.session, [setVarbind], function (err, result) {
    if (!err) {
      logger.info('[futureActuator:_set] set val=', result && 
        result[self.valueOid] && result[self.valueOid].toString());
        return cb && cb(null, value);
    } else {
      self.throttledChkSession();
      logger.error('[futureActuator:_set]snmp set failure', err, result);
      return cb && cb(new Error('snmp set failure'));
    }
  });
  return;
};

FutureActuator.prototype.__get = function (cb) {
  var self = this;

  if (!self.session) {
    self.throttledChkSession();
    logger.error('[futureActuator:_set]snmp session is not ready', self.id, self.model, self.ip);
    return cb && cb(new Error('snmp session is not ready'));
  }

  snmpHelper.getSNMP(self.session, self.valueOid, function (err, result) {
    var rtn = result && 
        result[self.valueOid] && result[self.valueOid].toString();
    if (!err && rtn && rtn !== 'N/A') {
        logger.info('[futureActuator:_set] set val=', rtn);
        return cb && cb(null, rtn);
    } else {
      self.throttledChkSession();
      logger.error('[futureActuator:_set]snmp set failure', err, result);
      if (!err && rtn === 'N/A') {
        return cb && cb(new Error('N/A value'));
      } else {
        return cb && cb(new Error('snmp set failure'));
      }
    }
  });
  return;
};

/* options.duration: infinite if NaN, null, undefined, zero or minus */
FutureActuator.prototype.set = function (options, cb) {
  var self = this;

  this._clearTimer();
  if (this.dataType !== 'temperatureController') {
    return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + this.dataType));
  }

  this.__set(JSON.stringify(options), function (err) {
    return _.isFunction(cb) && cb(err, err ? null : self.id + ' is on');
  });
};

FutureActuator.prototype._clearTimer = function () {
  if (this.blinkTimer) {
    clearInterval(this.blinkTimer);
    this.blinkTimer = null;
  }
  if (this.offTimer) {
    clearTimeout(this.offTimer);
    this.offTimer = null;
  }
};

FutureActuator.prototype._clear = function () {
  this._clearTimer();
  if (this.session) {
    this.session.close();
    delete this.session;
  }
  return;
};

module.exports = FutureActuator;
