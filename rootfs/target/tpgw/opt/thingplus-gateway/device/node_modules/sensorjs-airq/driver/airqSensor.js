'use strict';
var util = require('util'),
    _ = require('lodash');

var SensorLib = require('../'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger(),
    helper = require('../helper');

var CO2_IDX = 0,
TEMP_IDX = 2,
HUMI_IDX = 4;

function parseSensorData(buf) {
    var sensorData = {values: {}};
  sensorData.values.co2 = buf.getValues().readUInt16BE(CO2_IDX);
  sensorData.values.temperature = buf.getValues().readUInt16BE(TEMP_IDX) / 10;
  sensorData.values.humidity = buf.getValues().readUInt16BE(HUMI_IDX) / 10;

  return sensorData;
}

function AirqSensor(sensorInfo, options) {
  var self = this, serialPort, pollInterval;
  Sensor.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }

  this.dataType = _.first(AirqSensor.properties.dataTypes[this.model]);
  pollInterval = AirqSensor.properties.recommendedInterval[this.model];

  logger.debug('AirqSensor', sensorInfo);

  if (_.contains(AirqSensor.properties.supportedNetworks, sensorInfo.device.sensorNetwork) &&
  !_.isUndefined(sensorInfo.device.address)) {
    serialPort = sensorInfo.device.address;
    logger.info('airq sensor(addr: %s:%d) is created at driver', serialPort, sensorInfo);
  } else {
    logger.error('airq sensor address or network is not provided', sensorInfo);
  }
  helper.init({serialPort: serialPort, startAddress: 101, count: 5, pollInterval: pollInterval});
  helper.monitor.on('data', function (buf) {
    var rtn, sensorData;
//TODO: cache only the last value with expire time: recommended interval, error on expire
// OPTIONAL(note recommended): introducing new property: gather all values instead of the last value
    if (buf instanceof Error) {
      rtn = {
        id: self.id,
        status: 'error',
        message: buf.message,
      };
      self.emit('data', rtn);
      return;
    }
    sensorData = parseSensorData(buf);
    //check device addr
    if (sensorData.values[self.dataType]) {
      rtn = {
        id: self.id,
        status: 'ok',
        result: {},
      };
      rtn.result[self.dataType] = sensorData.values[self.dataType];
      if (sensorData.time) {
        rtn.time = {};
        rtn.time[self.dataType] = sensorData.time;
      }
      logger.debug('[AirqSensor] data', rtn);
      self.emit('data', rtn);
      return;
    }
  });
}


AirqSensor.properties = {
  supportedNetworks: ['serial'],
  dataTypes: { // use hash for diff types depending on model
    airqTemp: ['temperature'],
    airqHumi: ['humidity'],
    airqCo2: ['co2'],
  },
  onChange: {
    airqTemp: false,
    airqHumi: false,
    airqCo2: false,
  },
  discoverable: false,
  recommendedInterval: {
    airqTemp: 10000,
    airqHumi: 10000,
    airqCo2: 10000,
  },
  maxInstances: 1,
  models: ['airqTemp', 'airqHumi', 'airqCo2'],
  idTemplate: '{gatewayId}-{deviceAddress}-{type}',
  category: 'sensor'
};

util.inherits(AirqSensor, Sensor);

AirqSensor.prototype._get = function (cb) {
  var self = this,
      rtn = { id: self.id};

  if (!helper.isConnected()) {
    logger.error('AirqSensor:not connected', self.id, self.model);

    if (cb) {
      return cb(new Error('not connected'));
    } else {
      rtn.status = 'error';
      rtn.message = 'not connected';
      self.emit('data', rtn);
      return;
    }
  }

  if (!cb) {//already data emit listener is set
    return;
  }
  
  helper.monitor.once('data', function (buf) {
    var rtn, sensorData;

    if (buf instanceof Error) {
      rtn = {
        id: self.id,
      };
      return cb && cb(null, rtn);
    }
    sensorData = parseSensorData(buf);
    //check device addr
    if (sensorData.values[self.dataType]) {
      rtn = {
        id: self.id,
        status: 'ok',
        result: {},
      };
      rtn.result[self.dataType] = sensorData.values[self.dataType];
      if (sensorData.time) {
        rtn.time =  {};
        rtn.time[self.dataType] = sensorData.time;
      }
      logger.debug('[AirqSensor] data', rtn);
      return cb && cb(null, rtn);
    }
  });
};

AirqSensor.prototype._clear = function () {
//do nothing
};

module.exports = AirqSensor;
