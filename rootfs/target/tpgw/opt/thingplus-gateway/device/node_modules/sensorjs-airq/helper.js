'use strict';
var events      = require('events'),
util      = require('util'),
_      = require('lodash'),
logger = require('log4js').getLogger('Sensor'),
SerialPort = require('serialport').SerialPort,
modbus = require('h5.modbus');


var DEFAULT_OPTIONS = {
  startAddress: 101,
  count: 5,
  serialPort: 'USB0',
  pollInterval : 10 * 1000,
},
RECONNECT_INTERVAL = 60 * 1000,
MAX_RETRIES = 3;

var myOptions, _isConnected = false, underConnect = false, 
isInitialized = false, connectionKey;

var serialPort, master, session;

function Monitor() {
  events.EventEmitter.call(this);
}
util.inherits(Monitor, events.EventEmitter);
var monitor = exports.monitor = new Monitor();

//func decl
var reconnect, finConnection, initConnection;

initConnection = function (cb) {
  if (underConnect) {
    return cb && cb(new Error('underConnect'));
  }
  if (_isConnected) {
    return cb && cb(); //already connected
  }

  logger.info('[helper] myOptions', myOptions);
  underConnect = true;
  master = modbus.createMaster({
    transport: {
      type: 'rtu',
      eofTimeout: 10,
      connection: {
        type: 'serial',
        serialPort: new SerialPort('/dev/tty' + myOptions.serialPort, { baudRate: 9600 }),
      }
    },
    suppressTransactionErrors: false,
    retryOnException: true,
    maxConcurrentRequests: 1,
    defaultUnit: 0,
    defaultMaxRetries: 3,
    defaultTimeout: 100
  });
  master.on('connected', function()
  {
    var orgCb = cb;

    cb = null; // call once
    _isConnected = true;
    logger.info('[master#connected once]');
    return orgCb && orgCb();
  });

  master.on('disconnected', function()
  {
    _isConnected = false;
    reconnect();
    logger.info('[master#disconnected]');
  });

  master.on('error', function(err)
  {
    var orgCb = cb;

    cb = null; // call once
    _isConnected = false;
    reconnect();
    logger.error('[master#error once] %s', err.message);
    return orgCb && orgCb(err);
  });

  var slaveConnection = master.getConnection();

  slaveConnection.on('close', function()
  {
    logger.info('[slaveConnection#close]');
  });

  slaveConnection.on('error', function(err)
  {
    logger.info('[slaveConnection#error] %s', err.message);
    _isConnected = false;
    reconnect();
  });

  master.once('connected', function()
  {
    var serialErrorCount = 0;
    session = master.readHoldingRegisters(myOptions.startAddress, 
      myOptions.count, {
        unit: 1,
        maxRetries: 3,
        timeout: myOptions.pollInterval / 3,
        interval: myOptions.pollInterval,
      });

      session.on('timeout', function()
      {
        logger.info('[transaction#timeout]');
      });

      session.on('error', function(err)
      {
        logger.info('[transaction#error] %s', err.message);
        if (++serialErrorCount > (MAX_RETRIES * 2)) {
          var e = new Error('transaction error');
          logger.error('emit error', e);
          monitor.emit('data', e);
          _isConnected = false;
          reconnect();
          return;
        }
      });

      session.on('response', function(response)
      {
        if (response.isException() && response.getCount() !== myOptions.count)
        {
          logger.error('[transaction#response] %s', response);
          if (++serialErrorCount > (MAX_RETRIES * 2)) {
            var e = new Error('transaction response error');
            logger.error('emit error', e);
            monitor.emit('data', e);
            _isConnected = false;
            reconnect();
            return;
          }
        }
        else
        {
          logger.debug('emit data', response);
          monitor.emit('data', response);
          serialErrorCount = 0;
        }
      });

      session.on('cancel', function()
      {
        logger.info('[transaction#cancel]');
        serialErrorCount = 0;
      });
  });

};

//TODO: support multiple devices. aasumign only one device for now.
function init(opts, cb) {
  var key;

  myOptions = _.defaults(opts || {}, DEFAULT_OPTIONS);
  key = [myOptions.serialPort, myOptions.startAddress, myOptions.count].join(':');
  if (isInitialized) {
    if (connectionKey === key) { 
      return cb && cb();
    } else {
      return cb && cb(new Error('no new connection:' + key));
    }
  }
  connectionKey = key;
  isInitialized = true;

  serialPort = new SerialPort('/dev/tty' + myOptions.serialPort, { baudRate: 9600 });

  return initConnection(function () {
    return cb && cb(); // ignore error
  });
}


finConnection = function (cb) {
  var orgMaster = master, orgSession = session;
  master = null;
  session = null;

  _isConnected = false;
  underConnect = false;

  process.nextTick(function() {
    orgSession.cancel();
    orgMaster.destroy();
    return cb && cb();
  });
};

reconnect = _.throttle(function() {
  if (_isConnected) {
    return;
  } else {
    logger.error('[helper] airq reconnecting');
    finConnection(function () {
      initConnection();
    });
  }
}, RECONNECT_INTERVAL, {trailing: false});

function isConnected() {
  return _isConnected;
}

exports.init = init;
exports.monitor = monitor;
exports.isConnected = isConnected;

//run directly from node, example:
if (require.main === module) {
  init({serialPort: 'USB0', startAddress: 101, count: 5, pollInterval: 10000}, function (err) {
    logger.warn('init done', err);
  });
}
